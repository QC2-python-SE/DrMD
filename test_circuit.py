import pytest
import random as rand
from scipy.stats import unitary_group as ug
import numpy as np

from circuit import Circuit, random_circuit
import gate_list as gl
from unitary_gate import UnitaryGate, random_unitary
from qubit_state import QubitState

"""
A testing python file using the pytest framework for the Circuit class.

Main functionalities of the class are tested against random data.
This includes:
    - proper construction of Circuit objects
    - proper manipulation of Circuit objects (append, merge, pop, insert)
    - proper retrieval of data from Circuit objects 
    (get_element, copy, size, is_empty, compare)
    - proper use of Circuit objects (apply)

Expected errors to be raised are tested, and that the unitaries are 
stored within the circuits in new objects to avoid unexpected modifications
from the user. 
"""

# Tests for constructor 
def test_empty_init():
    """
    Function that tests that an empty circuit
    is properly generated by the constructor.
    """
    empty_circ = Circuit()
    assert empty_circ.is_empty()


def test_singleton_init():
    """
    Function that tests that a circuit of depth one
    is properly generated from a random unitary.
    """

    uni = random_unitary()
    circ1 = Circuit(uni)
    
    assert circ1.is_empty() == False
    assert circ1.size() == 1
    assert circ1.get_element(0).compare(uni)
    gate = circ1.pop()

    assert gate != uni  # Check they are distinct objects

    assert circ1.is_empty()


def test_list_init():
    """
    Function that tests circuits are properly
    generated from a random list of unitaries.
    """
    # Create random circuit
    gates = []
    for i in range(5):
        gates.append(random_unitary())

    circ = Circuit(gates)

    # Test size stored correct
    assert circ.is_empty() == False
    assert circ.size() == len(gates)

    # Test unitaries properly stored in new objects
    while circ.is_empty() == False:
        last = circ.pop()
        gate = gates.pop()
        assert last.compare(gate) # This indirectly tests __deepcopy
        assert last != gate  # Check they are at distinct addresses


def test_wrong_init():
    """
    Function that tests errors are properly raised 
    by constructor on invalid inputs.
    """

    matrix = gl.CNOT_mat  # Not UnitaryGate object

    # Test only list[UnitaryGate] or UnitaryGate inputs are accepted
    with pytest.raises(TypeError) as notList:
        Circuit(matrix)
        assert str(notList.value) == \
            "Input needs to be a list of elements UnitaryGate"

    gates = [gl.CNOT_mat, None]  # List of matrix objects
    with pytest.raises(TypeError) as notUni:
        Circuit(gates)
        assert str(notUni.value) == \
            "All elements of input list need to be UnitaryGate"
        
    gates = (gl.cnot, gl.x1)  # Tuple of UnitaryGate (not list)
    with pytest.raises(TypeError) as tupleIn:
        Circuit(gates)
        assert str(tupleIn.value) == \
            "Input needs to be a list of elements UnitaryGate"


# Tests for getters and functionalities
# ( Note: __str__ tested by printing in the notebooks,
#   __deepcopy tested within other functionalities)

def test_empty():
    """Test that is_empty returns True iff circuit is truly empty."""
    circ = Circuit()
    assert circ.is_empty()

    circ = Circuit(gl.cnot)
    assert not circ.is_empty()


def test_size():
    """Test that size returned is correct."""
    circ = Circuit()
    assert circ.size() == 0

    for i in range(10): # Test for multiple random data
        depth = rand.randint(1,20)
        circ = random_circuit(depth)
        assert circ.size() == depth


def test_append():
    """
    Function that tests that Circuit.append() appends copies of unitaries
    to circuit, and that the appended gate is stored at a new address.
    Also tests that on invalid input the corresponding error is raised.
    """
    
    circ = Circuit()
    gates = [gl.x1, gl.cnot, gl.hadamard1]

    curr_len = circ.size()  # Current depth of circ

    for u in gates:
        circ.append(u)

        # Check depth increased
        curr_len += 1 
        assert circ.size() == curr_len

        # Check last stored object
        assert circ.get_element(-1).compare(u)  # Check equal
        assert circ.get_element(-1) != u  # Check different address

    # Check circuits are equal at the end
    target_circuit = Circuit(gates)
    assert target_circuit.compare(circ)

    # Test error-raising
    with pytest.raises(TypeError) as invalid_append:
        circ.append(gl.CNOT_mat)  # Try append a matrix
        assert str(invalid_append.value) == \
            "Input must be a UnitaryGate"


def test_pop():
    """
    Function to test that UnitaryGate.pop() mimics 
    behavior of list.pop().
    """
    gates = [gl.x1, gl.cnot, gl.hadamard1, gl.hadamard2]
    circ = Circuit(gates)

    # Empty argument
    last_circ = circ.pop()
    last_gates = gates.pop()
    assert last_circ.compare(last_gates)

    # Numerical argument
    last_circ = circ.pop(-1)
    last_gates = gates.pop(-1)
    assert last_circ.compare(last_gates)

    first_c = circ.pop(0)
    first_g = gates.pop(0)
    assert first_c.compare(first_g)

    # Check remainder of circuit is as expected
    assert circ.size() == len(gates)
    new_circ = Circuit(gates)
    assert circ.compare(new_circ)


def test_get_element():
    """
    Function that tests the behavior of UnitaryGate.get_element() 
    against the behavior of lists, making sure that
    the function only returns copies of unitaries (and not
    the unitary at the address stored in circuit).
    """

    for i in range(10):
        # Generate random list of gates
        gates = []
        depth = rand.randint(1, 10)
        for i in range(depth):
            gates.append(random_unitary())
        
        circ = Circuit(gates)

        index = rand.randint(0, depth-1)

        uni_returned = circ.get_element(index)

        assert uni_returned.compare(gates[index])  # Check same as in list

        # Check get_element returns a copy with different address
        uni_popped = circ.pop(index)  # Object at address stored in circuit
        assert uni_returned.compare(uni_popped)
        assert uni_returned != uni_popped  


def test_insert():
    """
    Test on randomised circuits that insert works properly,
    inserting a copy of the gate in the circuit at the expected
    location. 
    Also tests that the rest of the circuit remains unmodified.
    """

    for i in range(10): # Test with multiple random data

        # Create random circuit
        depth = rand.randint(1, 20)
        circ = random_circuit(depth)

        # Create random valid index
        index = rand.randint(1, depth)

        # Insert valid unitary at index
        uni = random_unitary()
        original = circ.copy()
        circ.insert(index, uni)

        # Test correct size and element
        assert circ.size() == depth + 1
        assert circ.get_element(index).compare(uni)

        # Test appended object is at distinct address 
        uni_in_circ = circ.pop(index)
        assert uni != uni_in_circ

        # Test rest of circuit unmodified
        assert circ.compare(original)


def test_merge():
    """
    Function to test that .merge() properly collates randomised circuits.
    That is, that copies of the gates in the second circuit are 
    properly appended to the caller and stored in new objects.
    """
    
    # Test TypeError is properly raised
    circ1 = Circuit()
    with pytest.raises(TypeError) as invalid_in:
        circ1.merge(gl.CNOT_mat)  # Try append a matrix
        assert str(invalid_in.value) == \
            "Merged element must be of type Circuit"
    
    # Test merge functionality on multiple random data
    for i in range(10):
        depth1 = rand.randint(1, 5)
        circ1 = random_circuit(depth1)
    
        depth2 = rand.randint(1, 5)
        circ2 = random_circuit(depth2)

        og = circ1.copy()

        # Test two random circuits are properly merged
        circ1.merge(circ2)

        # Check correct size
        assert circ1.size() == depth1 + depth2

        # Check elements are correct
        for i in range(depth1):
            # Check first part is the original circ1
            u_circ1 = circ1.get_element(i)
            assert og.get_element(i).compare(u_circ1)
    
        for i in range(depth1, circ1.size()):
            # Check second part is circ2
            u_circ2 = circ2.get_element(i - depth1)
            assert circ1.get_element(i).compare(u_circ2)

        # Check elements merged are stored at new addresses
        last_1 = circ1.pop()
        last_2 = circ2.pop()
        assert last_1.compare(last_2)
        assert last_1 != last_2


def test_copy():
    """
    Function that tests on randomised circuits
    that copy() performs proper deep copy of
    caller. That is, tests that unitaries coincide
    and that they are stored at different addresses.
    """

    for i in range(10):
        depth1 = rand.randint(0, 10)
        circ1 = random_circuit(depth1)

        circ2 = circ1.copy()

        # Test size
        assert circ1.size() == circ2.size()

        # Test elements
        while not circ1.is_empty():
            u1 = circ1.pop()
            u2 = circ2.pop()
            assert u1.compare(u2)  # Check elements are identical
            assert u1 != u2  # Check different addresses


def test_compare():
    """
    Function that tests that .compare() resturns True 
    if and only if the contents of two circuits are identical.
    """
    gates = [gl.x1, gl.cnot, gl.hadamard1, gl.hadamard2]
    circ = Circuit(gates)

    # Test error is raised on list input
    with pytest.raises(TypeError) as invalid_in:
        circ.compare(gates)  
        assert str(invalid_in.value) == \
            "Input must be a Circuit"
        
    # Test comparisons work
    circ2 = Circuit()
    assert circ.compare(circ2) == False

    circ2.merge(circ)
    assert circ.compare(circ2)


def test_apply(): 
    """
    Function that tests on a number of random circuits 
    whether the action of the circuit on the computational 
    basis is as expected.
    Tests against the unitary corresponding to the action of
    the circuit.
    """

    for i in range(10):
        # Generate random list of unitaries and 
        # find unitary for corresponding circuit
        gates = []
        unitary_mat = np.kron(gl.I_mat, gl.I_mat)  # matrix for circuit

        depth = rand.randint(3, 10)
        
        for i in range(depth):
            u = ug.rvs(4)
            unitary_mat = u @ unitary_mat
            gates.append(UnitaryGate(u))

        unitary = UnitaryGate(unitary_mat)
        circ = Circuit(gates)

        # Check output from circuit corresponds to output from unitary

        comp_basis = [np.array([1,0,0,0])]
        comp_basis.append(np.array([0,1,0,0]))
        comp_basis.append(QubitState(np.array([0,0,1,0])))
        comp_basis.append(QubitState(np.array([0,0,0,1])))

        for state_in in comp_basis:
            out_circ = circ.apply(state_in)
            out_uni = unitary.apply(state_in)

            assert type(out_circ) == type(state_in)

            if type(out_circ) != QubitState:
                out_circ = QubitState(out_circ)
            
            assert out_circ.compare(out_uni)    
